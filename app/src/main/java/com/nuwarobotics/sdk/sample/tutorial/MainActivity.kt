package com.pinenuts.demo

import android.Manifest
import android.app.Activity
import android.app.AlertDialog
import android.content.Context
import android.content.DialogInterface
import android.content.pm.PackageManager
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaPlayer
import android.media.MediaRecorder
import android.os.Bundle
import android.os.Environment
import android.os.Handler
import android.util.Log
import android.view.View
import android.widget.Button
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Toast
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import com.nuwarobotics.service.IClientId
import com.nuwarobotics.service.agent.BnfData
import com.nuwarobotics.service.agent.NuwaRobotAPI
import com.nuwarobotics.service.agent.RobotEventListener
import com.nuwarobotics.service.agent.VoiceEventListener
import com.nuwarobotics.service.agent.VoiceEventListener.ListenType
import com.nuwarobotics.service.agent.VoiceEventListener.ResultType
import com.pinenuts.demo.databinding.ActivityMainBinding
import java.io.File
import java.io.IOException
import java.io.InputStream

class MainActivity : Activity(), View.OnClickListener {
    // 权限请求相关常量
    private val PERMISSIONS_REQUEST_CODE = 100
    private val REQUIRED_PERMISSIONS = arrayOf(
        Manifest.permission.RECORD_AUDIO,
        Manifest.permission.WRITE_EXTERNAL_STORAGE
    )
    
    // 录音和播放相关变量
    private var mediaRecorder: MediaRecorder? = null
    private var mediaPlayer: MediaPlayer? = null
    private var isRecording = false
    private var audioFilePath: String? = null
    private lateinit var btnRecord: Button
    private lateinit var btnPlay: Button
    private var audioChannelCount: Int = 1 // 存储音频输入设备的通道数量，默认为单声道
    private lateinit var tvAudioInfo: TextView // 显示音频信息的 TextView
    companion object {
        private const val TAG = "DannyDemo"
    }

    private lateinit var binding: ActivityMainBinding
    private lateinit var mLayout: LinearLayout
    private val mTestCases = arrayOf(
        "wakeup",
        "tts",
        
        // 缶詰のアクション再生
        "show window",
        "hide window",
        "motion list",
        "play a motion (no face)",
        "play a motion (with face)",
        "stop motion",
        
        // ASR
        "build grammar 1",
        "build grammar 2",
        "ASR",
        "語音輸入成文字",
        
        // LED
        "Enable LED control by App",
        "LED on 1(Control by App)",
        "LED on 2(Control by App)",
        "LED off (Control by App)",
        "Enable LED control by Robot",
        
        // Basic motor control
        "Control mortor 1(20)",
        "Control mortor 1(-20)",
        "Motion reset",
        
        // Advanced motion control for "control Robot to forward, backwards, turns, stop"
        "Movement control 1",
        "Movement control 2"
    )
    
    private lateinit var mBbs: Array<Button>
    private lateinit var mRobot: NuwaRobotAPI
    private lateinit var mToast: Toast
    private var mBuildGrammar: Boolean = false
    private var bEnableLEDControllByApp: Boolean = false
    
    // 脖子角度控制变量
    private var neckVerticalAngle: Float = 0f // 脖子上下角度，范围-20到20
    private var neckHorizontalAngle: Float = 0f // 脖子左右角度，范围-20到20

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        // UI handler
        mToast = Toast.makeText(this, "", Toast.LENGTH_SHORT)
        
        // init Nuwa Robot SDK with client_id and app_id which are generated by NUWA develop platform
        mRobot = NuwaRobotAPI(this, IClientId(packageName))

        // register Nuwa Robot Listener
        registerNuwaRobotListener()
        
        // 初始化脖子角度变量
        neckVerticalAngle = 0f
        neckHorizontalAngle = 0f
        
        // 初始化音频信息显示
        tvAudioInfo = findViewById(R.id.tv_audio_info)
        
        // 获取并显示音频输入设备信息
        getAudioInputChannelCount()
        
        // 检查并请求权限
        if (!checkPermissions()) {
            requestPermissions()
        }
        
        // 设置移动方向按钮的点击监听器
        findViewById<Button>(R.id.btn_up).setOnClickListener { up() }
        findViewById<Button>(R.id.btn_down).setOnClickListener { down() }
        findViewById<Button>(R.id.btn_left).setOnClickListener { left() }
        findViewById<Button>(R.id.btn_right).setOnClickListener { right() }
        findViewById<Button>(R.id.btn_stop).setOnClickListener { stop() }
        
        // 设置脖子控制按钮的点击监听器
        findViewById<Button>(R.id.btn_neck_up).setOnClickListener { neckUp() }
        findViewById<Button>(R.id.btn_neck_down).setOnClickListener { neckDown() }
        findViewById<Button>(R.id.btn_neck_left).setOnClickListener { neckLeft() }
        findViewById<Button>(R.id.btn_neck_right).setOnClickListener { neckRight() }
        findViewById<Button>(R.id.btn_neck_stop).setOnClickListener { neckStop() }
        
        // 初始化录音和播放按钮
        btnRecord = findViewById(R.id.btn_record)
        btnPlay = findViewById(R.id.btn_play)
        
        // 设置录音文件路径
        audioFilePath = getExternalFilesDir(null)?.absolutePath + "/nuwa_audio_record.3gp"
        
        // 设置录音按钮点击监听器
        btnRecord.setOnClickListener {
            if (isRecording) {
                stopRecording()
            } else {
                startRecording()
            }
        }
        
        // 设置播放按钮点击监听器
        btnPlay.setOnClickListener {
            playRecording()
        }
        
        // 获取并显示音频输入设备的通道数量
        getAudioInputChannelCount()
    }

    override fun onResume() {
        super.onResume()
        hideNavi()
        // 在恢复时重新获取音频输入设备信息
        getAudioInputChannelCount()
    }

    override fun onDestroy() {
        super.onDestroy()
        // 释放录音和播放资源
        releaseMediaRecorder()
        releaseMediaPlayer()
        
        // 重置脖子位置
        try {
            mRobot.ctlMotor(2, 0, 0f, 40f) // 重置上下运动
            mRobot.ctlMotor(3, 0, 0f, 40f) // 重置左右运动
        } catch (e: Exception) {
            Log.e(TAG, "重置脖子位置失败: ${e.message}")
        }
        
        // release Nuwa Robot SDK resource
        mRobot.release()
    }
    
    // 开始录音
    private fun startRecording() {
        try {
            // 释放之前的MediaRecorder
            releaseMediaRecorder()
            
            // 创建新的MediaRecorder
            mediaRecorder = MediaRecorder().apply {
                setAudioSource(MediaRecorder.AudioSource.MIC)
                setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP)
                setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB)
                setAudioChannels(audioChannelCount) // 设置录音通道数
                setOutputFile(audioFilePath)
                
                try {
                    prepare()
                    start()
                    isRecording = true
                    btnRecord.text = "停止录音"
                    btnPlay.isEnabled = false
                    showToast("开始录音")
                } catch (e: IOException) {
                    Log.e(TAG, "录音准备失败: ${e.message}")
                    showToast("录音准备失败")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "录音初始化失败: ${e.message}")
            showToast("录音初始化失败")
        }
    }
    
    // 停止录音
    private fun stopRecording() {
        try {
            mediaRecorder?.apply {
                stop()
                reset()
                release()
            }
            mediaRecorder = null
            isRecording = false
            btnRecord.text = "录音"
            btnPlay.isEnabled = true
            showToast("录音已保存")
            
            // 使用机器人TTS播报录音完成
            mRobot.startTTS("录音已完成，可以播放")
        } catch (e: Exception) {
            Log.e(TAG, "停止录音失败: ${e.message}")
            showToast("停止录音失败")
        }
    }
    
    // 播放录音
    private fun playRecording() {
        if (audioFilePath == null) {
            showToast("没有录音文件")
            return
        }
        
        try {
            // 释放之前的MediaPlayer
            releaseMediaPlayer()
            
            // 创建新的MediaPlayer
            mediaPlayer = MediaPlayer().apply {
                setDataSource(audioFilePath)
                setOnCompletionListener {
                    btnPlay.text = "播放"
                    btnRecord.isEnabled = true
                }
                prepare()
                start()
                btnPlay.text = "停止播放"
                btnRecord.isEnabled = false
                showToast("正在播放录音")
            }
        } catch (e: Exception) {
            Log.e(TAG, "播放录音失败: ${e.message}")
            showToast("播放录音失败")
        }
    }
    
    // 释放MediaRecorder资源
    private fun releaseMediaRecorder() {
        if (isRecording) {
            try {
                mediaRecorder?.stop()
            } catch (e: Exception) {
                Log.e(TAG, "停止录音失败: ${e.message}")
            }
            isRecording = false
        }
        mediaRecorder?.release()
        mediaRecorder = null
        btnRecord.text = "录音"
    }
    
    // 释放MediaPlayer资源
    private fun releaseMediaPlayer() {
        mediaPlayer?.release()
        mediaPlayer = null
        btnPlay.text = "播放"
        btnRecord.isEnabled = true
    }
    
    // 获取音频输入设备的通道数量
    private fun getAudioInputChannelCount() {
        try {
            // 尝试创建不同通道配置的 AudioRecord 实例来检测支持的通道数
            val sampleRate = 44100 // 标准采样率
            
            // 先尝试立体声
            var minBufferSize = AudioRecord.getMinBufferSize(
                sampleRate,
                AudioFormat.CHANNEL_IN_STEREO, // 尝试立体声
                AudioFormat.ENCODING_PCM_16BIT
            )
            
            if (minBufferSize != AudioRecord.ERROR_BAD_VALUE) {
                // 设备支持立体声录音
                audioChannelCount = 2
                
                // 创建临时 AudioRecord 实例以获取更多信息
                val tempRecorder = AudioRecord(
                    MediaRecorder.AudioSource.MIC,
                    sampleRate,
                    AudioFormat.CHANNEL_IN_STEREO,
                    AudioFormat.ENCODING_PCM_16BIT,
                    minBufferSize
                )
                
                if (tempRecorder.state == AudioRecord.STATE_INITIALIZED) {
                    // 获取更多音频信息
                    val channelInfo = "音频输入设备通道数：$audioChannelCount"
                    val sampleRateInfo = "采样率：$sampleRate Hz"
                    val bufferSizeInfo = "缓冲区大小：$minBufferSize bytes"
                    
                    // 更新 TextView 显示详细信息
                    tvAudioInfo.text = "$channelInfo | $sampleRateInfo"
                    
                    Log.d(TAG, channelInfo)
                    Log.d(TAG, sampleRateInfo)
                    Log.d(TAG, bufferSizeInfo)
                    
                    // 释放临时资源
                    tempRecorder.release()
                }
            } else {
                // 尝试单声道
                minBufferSize = AudioRecord.getMinBufferSize(
                    sampleRate,
                    AudioFormat.CHANNEL_IN_MONO,
                    AudioFormat.ENCODING_PCM_16BIT
                )
                
                if (minBufferSize != AudioRecord.ERROR_BAD_VALUE) {
                    // 设备支持单声道录音
                    audioChannelCount = 1
                    
                    // 更新 TextView 显示通道数量
                    tvAudioInfo.text = "音频输入设备通道数：$audioChannelCount | 采样率：$sampleRate Hz"
                    
                    Log.d(TAG, "音频输入设备通道数：$audioChannelCount")
                    Log.d(TAG, "采样率：$sampleRate Hz")
                    Log.d(TAG, "缓冲区大小：$minBufferSize bytes")
                } else {
                    // 无法确定通道数
                    audioChannelCount = 0
                    tvAudioInfo.text = "无法确定音频输入设备通道数"
                    Log.e(TAG, "无法确定音频输入设备通道数")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "获取音频通道数量失败: ${e.message}")
            tvAudioInfo.text = "音频输入设备通道数：获取失败"
            // 默认设置为单声道，以确保录音功能正常工作
            audioChannelCount = 1
        }
    }

    private fun hideNavi() {
        // View decorView = getWindow().getDecorView();
        // int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN;
        // decorView.setSystemUiVisibility(uiOptions);
    }

    private fun loadData(cx: Context, inFile: String): String {
        var tContents = ""
        try {
            val stream = cx.assets.open(inFile)
            val size = stream.available()
            val buffer = ByteArray(size)
            stream.read(buffer)
            stream.close()
            tContents = String(buffer)
        } catch (e: IOException) {
            // Handle exceptions here
        }
        return tContents
    }

    private fun registerNuwaRobotListener() {
        mRobot.registerRobotEventListener(object : RobotEventListener {
            override fun onWikiServiceStart() {
                Log.d(TAG, "onWikiServiceStart")
                showToast("onWikiServiceStart:")
                mRobot.startTTS("機器人準備好了")
                mRobot.hideWindow(false)
            }

            override fun onWikiServiceStop() {
                Log.d(TAG, "onWikiServiceStop")
            }

            override fun onWikiServiceCrash() {
                Log.d(TAG, "onWikiServiceCrash")
            }

            override fun onWikiServiceRecovery() {
                Log.d(TAG, "onWikiServiceRecovery")
            }

            override fun onStartOfMotionPlay(motion: String) {
                Log.d(TAG, "onStartOfMotionPlay:$motion")
                showToast("onStartOfMotionPlay:$motion")
            }

            override fun onPauseOfMotionPlay(motion: String) {
                Log.d(TAG, "onPauseOfMotionPlay:$motion")
            }

            override fun onStopOfMotionPlay(motion: String) {
                Log.d(TAG, "onStopOfMotionPlay:$motion")
                showToast("onStopOfMotionPlay:$motion")
            }

            override fun onCompleteOfMotionPlay(motion: String) {
                Log.d(TAG, "onCompleteOfMotionPlay:$motion")
                showToast("onCompleteOfMotionPlay:$motion")
                mRobot.hideWindow(false)
            }

            override fun onPlayBackOfMotionPlay(motion: String) {
                Log.d(TAG, "onPlayBackOfMotionPlay:$motion")
            }

            override fun onErrorOfMotionPlay(errorcode: Int) {
                Log.d(TAG, "onErrorOfMotionPlay:$errorcode")
                mRobot.hideWindow(false)
            }

            override fun onPrepareMotion(b: Boolean, s: String, v: Float) {
            }

            override fun onCameraOfMotionPlay(motion: String) {
                Log.d(TAG, "onCameraOfMotionPlay:$motion")
            }

            override fun onGetCameraPose(
                x: Float, y: Float, z: Float,
                Xx: Float, Yx: Float, Zx: Float,
                Xy: Float, Yy: Float, Zy: Float,
                Xz: Float, Yz: Float, Zz: Float
            ) {
            }

            override fun onTouchEvent(type: Int, touch: Int) {
                Log.d(TAG, "onTouchEvent:$type, touch:$touch")
            }

            override fun onPIREvent(value: Int) {
                Log.d(TAG, "onPIREvent:$value")
            }

            override fun onTap(body: Int) {
                Log.d(TAG, "onTap:$body")
            }

            override fun onLongPress(body: Int) {
                Log.d(TAG, "onLongPress:$body")
            }

            override fun onWindowSurfaceReady() {
                Log.d(TAG, "onWindowSurfaceReady")
            }

            override fun onWindowSurfaceDestroy() {
                Log.d(TAG, "onWindowSurfaceDestroy")
            }

            override fun onTouchEyes(eyeLR: Int, type: Int) {
                Log.d(TAG, "onTouchEyes:$eyeLR, type:$type")
            }

            override fun onRawTouch(i: Int, i1: Int, i2: Int) {
            }

            override fun onFaceSpeaker(direction: Float) {
                Log.d(TAG, "onFaceSpeaker:$direction")
            }

            override fun onActionEvent(i: Int, i1: Int) {
            }

            override fun onDropSensorEvent(i: Int) {
                Log.d(TAG, "onDropSensorEvent:$i")
            }

            override fun onMotorErrorEvent(i: Int, i1: Int) {
                Log.d(TAG, "onMotorErrorEvent:$i")
            }
        })

        mRobot.registerVoiceEventListener(object : VoiceEventListener {
            override fun onWakeup(isError: Boolean, score: String, direction: Float) {
                Log.d(TAG, "onWakeup:${!isError}, score:$score")
                showToast("onWakeup:${!isError}, score:$score")
            }

            override fun onTTSComplete(isError: Boolean) {
                Log.d(TAG, "onTTSComplete${!isError}")
                showToast("onTTSComplete:${!isError}")
            }

            override fun onSpeechRecognizeComplete(isError: Boolean, iFlyResult: ResultType, json: String) {
                Log.d(TAG, "onSpeechRecognizeComplete:${!isError}, json:$json")
                showToast("雲端結果：$json")
            }

            override fun onSpeech2TextComplete(isError: Boolean, json: String) {
                Log.d(TAG, "onSpeech2TextComplete:${!isError}, json:$json")
                showToast("語音轉文字(語音輸入法)：$json")
            }

            override fun onSpeechState(type: ListenType, state: VoiceEventListener.SpeechState) {
                Log.d(TAG, "onSpeechState:$type, state:$state")
            }

            override fun onMixUnderstandComplete(isError: Boolean, iFlyResult: ResultType, json: String) {
                Log.d(TAG, "onMixUnderstandComplete:${!isError}, json:$json")
                if (!isError) {
                    if (iFlyResult == ResultType.LOCAL_COMMAND) {
                        showToast("local ASR:$json")
                    } else {
                        showToast("cloud ASR:$json")
                    }
                } else {
                    mRobot.startTTS("網路或訊飛不夠力")
                    showToast("網路或訊飛不夠力 $json")
                }
            }

            override fun onGrammarState(isError: Boolean, info: String) {
                Log.d(TAG, "onGrammarState:${!isError}, info:$info")

            }

            override fun onListenVolumeChanged(listenType: ListenType, volume: Int) {
            }

            override fun onSpeakState(type: VoiceEventListener.SpeakType, state: VoiceEventListener.SpeakState) {
                Log.d(TAG, "onSpeakState:$type, state:$state")
            }
        })
    }


    private fun showToast(message: String) {
        mToast.setText(message)
        mToast.show()
    }
    
    // 检查是否已授予所需权限
    private fun checkPermissions(): Boolean {
        for (permission in REQUIRED_PERMISSIONS) {
            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {
                return false
            }
        }
        return true
    }
    
    // 请求所需权限
    private fun requestPermissions() {
        ActivityCompat.requestPermissions(this, REQUIRED_PERMISSIONS, PERMISSIONS_REQUEST_CODE)
    }
    
    // 处理权限请求结果
    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
        if (requestCode == PERMISSIONS_REQUEST_CODE) {
            if (grantResults.isNotEmpty() && grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
                showToast("已获取所需权限")
            } else {
                showToast("未获取所需权限，录音功能可能无法正常使用")
            }
        }
    }

    override fun onClick(v: View) {
        val tag = mTestCases[v.id]
        Log.d(TAG, "test case:$tag")

        when (tag) {
            "wakeup" -> {
                showToast("你可以說: 小丹小丹 or 凱比凱比，視機器人端的sku")
                mRobot.startWakeUp(true)
            }
            "tts" -> mRobot.startTTS("大家好，我是可愛的小機器人")
            "show window" -> mRobot.showWindow(false)
            "hide window" -> mRobot.hideWindow(false)
            "motion list" -> showMotionList()
            "play a motion (no face)" -> {
                hideNavi()
                mRobot.motionPlay("666_IM_Bird", false)
            }
            "play a motion (with face)" -> {
                hideNavi()
                mRobot.motionPlay("001_P4_Tutorial010", true)
            }
            "stop motion" -> mRobot.motionStop(false)
            "build grammar 1" -> {
                mBuildGrammar = false
                buildGrammar1()
            }
            "build grammar 2" -> {
                mBuildGrammar = false
                buildGrammar2()
            }
            "ASR" -> {
                showToast("請開始說話")
                if (mBuildGrammar) {
                    mRobot.startMixUnderstand()
                } else {
                    mRobot.startSpeech2Text(false)
                }
            }
            "Enable LED control by App" -> {
                mRobot.disableSystemLED()
                bEnableLEDControllByApp = true
            }
            "LED on 1(Control by App)" -> if (bEnableLEDControllByApp) rgb()
            "LED on 2(Control by App)" -> if (bEnableLEDControllByApp) rgb2()
            "LED off (Control by App)" -> if (bEnableLEDControllByApp) offled()
            "Enable LED control by Robot" -> {
                mRobot.enableSystemLED()
                bEnableLEDControllByApp = false
            }
            "語音輸入成文字" -> mRobot.startSpeech2Text(false)
            "Control mortor 1(20)" -> mRobot.ctlMotor(1, 0, 20f, 40f)
            "Control mortor 1(-20)" -> mRobot.ctlMotor(1, 0, -20f, 40f)
            "Motion reset" -> mRobot.motionReset()
            "Movement control 1" -> mRobot.turnLeftEx()
            "Movement control 2" -> mRobot.stopTurnEx()
        }
    }

    private fun showMotionList() {
        AlertDialog.Builder(this).apply {
            setTitle("Available Motion list")
            setNeutralButton("Cancel") { _, _ -> hideNavi() }
            if (mRobot.isKiWiServiceReady) {
                val mMotionList = mRobot.motionList.sorted()
                setItems(mMotionList.toTypedArray()) { _, which ->
                    hideNavi()
                    mRobot.motionPlay(mMotionList[which], true)
                }
                show()
            } else {
                showToast("Robot service is not ready")
            }
        }
    }

    /*
    Led01_head = 臉部兩側LED燈
    Led02_neck = 胸前LED燈
    Led03_R_hand = 右手LED燈
    Led04_L_hand = 左手LED燈
    */
    private fun rgb() {
        // turn on LED
        mRobot.apply {
            enableLed(1, 1) // 頭
            enableLed(2, 1) // 胸
            enableLed(3, 1) // 右手
            enableLed(4, 1) // 左手

            // Set LED color
            setLedColor(1, 255, 255, 0, 0)
            setLedColor(2, 255, 0, 0, 255)
            setLedColor(3, 255, 0, 255, 0)
            setLedColor(4, 255, 0, 255, 0)

            // Switch to "Breath mode"
            enableLedBreath(1, 2, 9)
            enableLedBreath(2, 2, 9)
            enableLedBreath(3, 2, 9)
            enableLedBreath(4, 2, 9)
        }
    }

    private fun rgb2() {
        // turn on LED
        mRobot.apply {
            enableLed(1, 1) // 頭
            enableLed(2, 1) // 胸
            enableLed(3, 1) // 右手
            enableLed(4, 1) // 左手

            // Set LED color
            setLedColor(1, 255, 255, 0, 0)
            setLedColor(2, 255, 0, 0, 255)
            setLedColor(3, 255, 0, 255, 0)
            setLedColor(4, 255, 0, 255, 0)
        }
    }

    private fun offled() {
        // turn off LED
        mRobot.apply {
            enableLed(1, 0) // 頭
            enableLed(2, 0) // 胸
            enableLed(3, 0) // 右手
            enableLed(4, 0) // 左手
        }
    }

    // 方法一, 程式runtime建立
    private fun buildGrammar1() {
        val mBnfData = BnfData("cmd")
        mBnfData.addSlot("fruit", true, 1, "着")
        mBnfData.addSlot("fruit", true, 1, "跳一支舞")
        mBnfData.addSlot("fruit", true, 1, "握手")
        mBnfData.addSlot("fruit", true, 1, "拍照")
        mBnfData.addSlot("fruit", true, 1, "超可爱")
        mBnfData.addSlot("fruit", true, 1, "谢谢")
        mBnfData.updateBody()
        Log.d(TAG, mBnfData.body)
        mRobot.createCrammer("cmd", mBnfData.body)
    }

    // 方法二, 從檔案建立
    private fun buildGrammar2() {
        val grammar = loadData(this, "grammar.txt")
        Log.d(TAG, grammar)
        mRobot.createCrammer("call", grammar)
    }
    
    // 方向控制函数
    private fun up() {
        Log.d(TAG, "Direction: Up")
        showToast("向前移动")
        // 使用SDK中的前进方法
        mRobot.move(0.2f)
        //mRobot.forwardInAccelerationEx()
    }
    
    private fun down() {
        Log.d(TAG, "Direction: Down")
        showToast("向后移动")
        // 使用SDK中的后退方法
        mRobot.move(-0.2f)
        //mRobot.backInAccelerationEx()
    }
    
    private fun left() {
        Log.d(TAG, "Direction: Left")
        showToast("向左转")
        // 使用SDK中的左转方法
        mRobot.turn(30f)
        //mRobot.turnLeftEx()
    }
    
    private fun right() {
        Log.d(TAG, "Direction: Right")
        showToast("向右转")
        // 使用SDK中的右转方法
        mRobot.turn(-30f)

        //mRobot.turnRightEx()
    }
    
    private fun stop() {
        Log.d(TAG, "Direction: Stop")
        showToast("停止移动")
        // 使用SDK中的停止方法
        mRobot.stopTurnEx()
        mRobot.stopInAccelerationEx()
        mRobot.move(0f)
        mRobot.turn(0f)
    }
    
    // 脖子控制函数
    private fun neckUp() {
        Log.d(TAG, "Neck Direction: Up")
        // 增加脖子上下角度，每次增加2度，最大20度
        neckVerticalAngle = (neckVerticalAngle - 2f).coerceAtMost(20f)
        showToast("脖子向上: $neckVerticalAngle 度")
        // 使用SDK中的电机控制方法控制脖子向上
        // 假设电机2控制脖子上下运动，正值表示向上
        mRobot.ctlMotor(1, 0, neckVerticalAngle, 30f)
    }
    
    private fun neckDown() {
        Log.d(TAG, "Neck Direction: Down")
        // 减少脖子上下角度，每次减少2度，最小-20度
        neckVerticalAngle = (neckVerticalAngle + 2f).coerceAtLeast(-20f)
        showToast("脖子向下: $neckVerticalAngle 度")
        // 使用SDK中的电机控制方法控制脖子向下
        // 假设电机2控制脖子上下运动，负值表示向下
        mRobot.ctlMotor(1, 0, neckVerticalAngle, 30f)
    }
    
    private fun neckLeft() {
        Log.d(TAG, "Neck Direction: Left")
        // 增加脖子左右角度，每次增加2度，最大20度
        neckHorizontalAngle = (neckHorizontalAngle + 2f).coerceAtMost(40f)
        showToast("脖子向左: $neckHorizontalAngle 度")
        // 使用SDK中的电机控制方法控制脖子向左
        // 假设电机3控制脖子左右运动，正值表示向左
        mRobot.ctlMotor(2, 0, neckHorizontalAngle, 30f)
    }
    
    private fun neckRight() {
        Log.d(TAG, "Neck Direction: Right")
        // 减少脖子左右角度，每次减少2度，最小-20度
        neckHorizontalAngle = (neckHorizontalAngle - 2f).coerceAtLeast(-40f)
        showToast("脖子向右: $neckHorizontalAngle 度")
        // 使用SDK中的电机控制方法控制脖子向右
        // 假设电机3控制脖子左右运动，负值表示向右
        mRobot.ctlMotor(2, 0, neckHorizontalAngle, 30f)
    }
    
    private fun neckStop() {
        Log.d(TAG, "Neck Direction: Stop")
        // 重置脖子角度为0
        neckVerticalAngle = 0f
        neckHorizontalAngle = 0f
        showToast("脖子归位")
        // 停止脖子电机并重置位置
        mRobot.ctlMotor(1, 0, 0f, 30f) // 重置上下运动
        mRobot.ctlMotor(2, 0, 0f, 30f) // 重置左右运动
    }
}